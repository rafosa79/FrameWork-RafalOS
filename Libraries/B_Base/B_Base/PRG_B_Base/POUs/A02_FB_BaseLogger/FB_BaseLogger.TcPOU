<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_BaseLogger" Id="{e337bc65-3f4c-06e8-12c9-a1d49597b716}" SpecialFunc="None">
    <Declaration><![CDATA[(*			
	RAFALOS
	Rafał Osajda		19.09.2025		TC 4024.66
	Moduł logujący wszsytkie zgłoszenia
*)
FUNCTION_BLOCK FB_BaseLogger EXTENDS FB_Base IMPLEMENTS ITF_BaseLogger, ITF_BaseLogger_HMI_Connector
VAR
	stBuffer						: ST_BaseEvents_Queue;
	uiNumerOfReportsIntheSystem		: UINT;						//informacja ogólna o ilosc wszystkich zgłoszeń
	bClearMemory					: BOOL;						//czyści pamięć
END_VAR
VAR PERSISTENT
	stMemory						: ST_BaseEvents_Memory;			//zapamiętane zgłoszenia
	stNumberOfReports				: ST_BaseEvents_ActiveEvents;	//ilości różnych zgłoszęń w rozróżnieniu na kategorie
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[	(*	Pobranie z kolejki zgłoszeń i dodanie do pamięci	*)

WHILE THIS^.stBuffer.iNumerOfEvents > 0 DO
	THIS^.BufferFIFOSupport ();
END_WHILE

IF (THIS^.bClearMemory) THEN
	THIS^.bClearMemory				:= FALSE;
	Tc2_System.MEMSET (
		destAddr					:= ADR (THIS^.stMemory),
		fillByte					:= 0,
		n							:= SIZEOF (THIS^.stMemory)
	);
	Tc2_System.MEMSET (
		destAddr					:= ADR (THIS^.stNumberOfReports),
		fillByte					:= 0,
		n							:= SIZEOF (THIS^.stNumberOfReports)
	);
END_IF
]]></ST>
    </Implementation>
    <Folder Name="ITF_BaseLogger" Id="{c54055ab-2569-0322-10a1-be1e8232e254}" />
    <Folder Name="ITF_BaseLogger_HMI_Connector" Id="{58ae1150-aaab-05cc-1931-89d90fea9543}" />
    <Method Name="BufferFIFOSupport" Id="{e129154d-ae16-0d4d-3b2a-e5726803dcad}">
      <Declaration><![CDATA[(*			
	EVERDE sp. z o.o.
	Rafał Osajda		09.06.2025		TC 4024.66
	Przenisienie danych z kolejki do zgloszen pamiętanych
*)
METHOD PRIVATE BufferFIFOSupport
]]></Declaration>
      <Implementation>
        <ST><![CDATA[	
	(*	W zależnosci od tego czy to jest nowe, aktualizacja czy zokończenie zadanie wykonaj odpowiednie zadanie 	*)
IF (THIS^.stBuffer.iNumerOfEvents > 0) THEN
	CASE THIS^.stBuffer.arrEvents [1].eEventAction OF
		E_BaseEvents_Action.Start				: 	THIS^.BufferFIFOSupportStart ();
		E_BaseEvents_Action.Confirm				: 	THIS^.BufferFIFOSupportConfirm ();
		E_BaseEvents_Action.Stop				: 	THIS^.BufferFIFOSupportStop ();
	END_CASE
	
(*		przesuniecie danych w kolejce o 1 i zmniejszenie liczy w kolejce o jeden 	*)
	
	Tc2_System.MEMCPY (
		destAddr			:= ADR (THIS^.stBuffer.arrEvents [1]),
		srcAddr				:= ADR (THIS^.stBuffer.arrEvents [2]),
		n					:= (SIZEOF (THIS^.stBuffer.arrEvents [1]) * TO_UINT (THIS^.stBuffer.iNumerOfEvents))
	);
	THIS^.stBuffer.iNumerOfEvents	:= THIS^.stBuffer.iNumerOfEvents - 1;
	
	THIS^.stBuffer.bChangeInMemory	:= TRUE;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="BufferFIFOSupportConfirm" Id="{f1844e3b-d002-0aae-0a0a-7787991dac5a}">
      <Declaration><![CDATA[(*			
	EVERDE sp. z o.o.
	Rafał Osajda		09.06.2025		TC 4024.66
	znalezienie w pamiętach odpowiedniego wiersza i przepisanie danych 
*)
METHOD PRIVATE BufferFIFOSupportConfirm
VAR_INPUT
END_VAR

VAR
	iI: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//szukanie w tablicy pamiętanych danych z pierwszego wierszza kolejki 

FOR iI := 1 TO TO_INT (THIS^.stPamiec.iIlosc) DO 
	IF (THIS^.stPamiec.arrWiersz [iI].uiIDZgloszenia = THIS^.stKolejka.arrZgloszenie [1].uiIDZgloszenia AND
		((THIS^.stPamiec.arrWiersz [iI].bPotwierdz AND NOT THIS^.stPamiec.arrWiersz [iI].bPotwierdzone) OR NOT THIS^.stPamiec.arrWiersz [iI].bPotwierdz)) THEN
		THIS^.stPamiec.arrWiersz [iI].bPotwierdzone		:= TRUE;
		THIS^.stPamiec.arrWiersz [iI].dtZatwierdzenie	:= THIS^.stKolejka.arrZgloszenie [1].dtZatwierdzenie;
		THIS^.ZmniejszIloscPotwierdzen ();
		EXIT;
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="BufferFIFOSupportStart" Id="{19eeb431-8176-061d-17ea-c2f43dedc551}">
      <Declaration><![CDATA[(*			
	EVERDE sp. z o.o.
	Rafał Osajda		09.06.2025		TC 4024.66
	Przenisienie pamietanych o jeden, zwiekszenie liczby pamietanych o jeden 
	przekopiowanie z koeljki wiersz 1 
*)
METHOD PRIVATE BufferFIFOSupportStart
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Tc2_System.MEMCPY (
	destAddr			:= ADR (THIS^.stMemory.arrRow [2]),
	srcAddr				:= ADR (THIS^.stMemory.arrRow [1]), 
	n					:= (SIZEOF (THIS^.stMemory.arrRow [1]) * TO_UINT (THIS^.stMemory.iNumberOfRow))
);
Tc2_System.MEMSET (
	destAddr			:= ADR (THIS^.stMemory.arrRow [1]),
	fillByte			:= 0,
	n					:= SIZEOF (THIS^.stMemory.arrRow [1])
);
THIS^.stmemory.arrRow [1].bActive				:= THIS^.stBuffer.arrEvents [1].bActive;
THIS^.stmemory.arrRow [1].bIgnoreRepetitions	:= THIS^.stBuffer.arrEvents [1].bIgnoreRepetitions;
THIS^.stmemory.arrRow [1].eEventCategory		:= THIS^.stBuffer.arrEvents [1].eEventCategory;
THIS^.stmemory.arrRow [1].uiIDEvent				:= THIS^.stBuffer.arrEvents [1].uiIDEvent;
THIS^.stmemory.arrRow [1].uiRepetitionCounter	:= THIS^.stBuffer.arrEvents [1].uiRepetitionCounter;
THIS^.stmemory.arrRow [1].dtStart				:= THIS^.stBuffer.arrEvents [1].dtStart;
THIS^.stmemory.arrRow [1].bConfirm				:= THIS^.stBuffer.arrEvents [1].bConfirmed;
THIS^.stmemory.arrRow [1].uiIDItem				:= THIS^.stBuffer.arrEvents [1].uiIDItem;

THIS^.stMemory.iNumberOfRow						:= THIS^.stMemory.iNumberOfRow + 1;

THIS^.stNumberOfReports.arrInfoForHMI [THIS^.stKolejka.arrZgloszenie [1].uiIDElementu].bNowe	:= TRUE;
THIS^.stNumberOfReports.arrInfoForHMI [THIS^.stKolejka.arrZgloszenie [1].uiIDElementu].iIlosc	:= THIS^.stIlosciZgloszonych.arrInfoDlaHMI [THIS^.stKolejka.arrZgloszenie [1].uiIDElementu].iIlosc + 1;
THIS^.stNumberOfReports.bNewEventsForHmi	:= TRUE;

	(*	informacja dla systemu że jest aktywny błąd 	*)
THIS^.ZwiekszIloscAktywnychBledow (
	bPotwierdzenie					:= THIS^.stPamiec.arrWiersz [1].bPotwierdz,
	eRodzajZgloszenia				:= THIS^.stPamiec.arrWiersz [1].eRodzajZgloszenia
);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="BufferFIFOSupportStop" Id="{4a2dc8bf-8638-0f38-0bfd-d5f6d09101e0}">
      <Declaration><![CDATA[(*			
	EVERDE sp. z o.o.
	Rafał Osajda		09.06.2025		TC 4024.66
	Znalezienie w pamieci odpowiedniego wiersza i przypisanie odpowiednich danych stempel i zmiena flagi
*)
METHOD PRIVATE BufferFIFOSupportStop
VAR_INPUT
END_VAR

VAR
	iI: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR iI := 1 TO TO_INT (THIS^.stPamiec.iIlosc) DO 
	IF (THIS^.stPamiec.arrWiersz [iI].uiIDZgloszenia = THIS^.stKolejka.arrZgloszenie [1].uiIDZgloszenia AND
		((THIS^.stPamiec.arrWiersz [iI].bPotwierdz AND THIS^.stPamiec.arrWiersz [iI].bPotwierdzone) OR NOT THIS^.stPamiec.arrWiersz [iI].bPotwierdz)) THEN
		THIS^.stPamiec.arrWiersz [iI].bAktywne		:= FALSE;
		THIS^.stPamiec.arrWiersz [iI].dtKoniec		:= THIS^.stKolejka.arrZgloszenie [1].dtKoniec;
		THIS^.ZmniejszIloscAktywnychBledow (eRodzajZgloszenia	:= THIS^.stPamiec.arrWiersz [iI].eRodzajZgloszenia);
		EXIT;
	END_IF
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="MetodaBaseLogerHMIConnector" Id="{2c18dbe3-a520-0877-1292-b2d303ed756b}" FolderPath="ITF_BaseLogger_HMI_Connector\">
      <Declaration><![CDATA[METHOD MetodaBaseLogerHMIConnector : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReportEvent" Id="{f0263bde-b6df-0833-2a35-a64ae2a95f5b}" FolderPath="ITF_BaseLogger\">
      <Declaration><![CDATA[METHOD PUBLIC ReportEvent : BOOL
VAR_INPUT
	stEvent					: ST_BaseEvents_RowInQueue;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>